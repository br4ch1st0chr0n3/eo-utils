-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Eo.Par
  ( happyError
  , myLexer
  , pINDENT
  , pINDENT_STAR
  , pListINDENT_STAR
  , pLINEBREAKA
  , pEOL
  ) where

import Prelude

import qualified Eo.Abs
import Eo.Lex

}

%name pINDENT INDENT
%name pINDENT_STAR INDENT_STAR
%name pListINDENT_STAR ListINDENT_STAR
%name pLINEBREAKA LINEBREAKA
%name pEOL EOL
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  L_ROOT      { PT _ (T_ROOT $$)      }
  L_STAR      { PT _ (T_STAR $$)      }
  L_DOTS      { PT _ (T_DOTS $$)      }
  L_CONST     { PT _ (T_CONST $$)     }
  L_SLASH     { PT _ (T_SLASH $$)     }
  L_COLON     { PT _ (T_COLON $$)     }
  L_COPY      { PT _ (T_COPY $$)      }
  L_ARROW     { PT _ (T_ARROW $$)     }
  L_VERTEX    { PT _ (T_VERTEX $$)    }
  L_SIGMA     { PT _ (T_SIGMA $$)     }
  L_XI        { PT _ (T_XI $$)        }
  L_PLUS      { PT _ (T_PLUS $$)      }
  L_MINUS     { PT _ (T_MINUS $$)     }
  L_QUESTION  { PT _ (T_QUESTION $$)  }
  L_SPACE     { PT _ (T_SPACE $$)     }
  L_DOT       { PT _ (T_DOT $$)       }
  L_LSQ       { PT _ (T_LSQ $$)       }
  L_RSQ       { PT _ (T_RSQ $$)       }
  L_LB        { PT _ (T_LB $$)        }
  L_RB        { PT _ (T_RB $$)        }
  L_AT        { PT _ (T_AT $$)        }
  L_RHO       { PT _ (T_RHO $$)       }
  L_HASH      { PT _ (T_HASH $$)      }
  L_LINEBREAK { PT _ (T_LINEBREAK $$) }

%%

ROOT :: { Eo.Abs.ROOT }
ROOT  : L_ROOT { Eo.Abs.ROOT $1 }

STAR :: { Eo.Abs.STAR }
STAR  : L_STAR { Eo.Abs.STAR $1 }

DOTS :: { Eo.Abs.DOTS }
DOTS  : L_DOTS { Eo.Abs.DOTS $1 }

CONST :: { Eo.Abs.CONST }
CONST  : L_CONST { Eo.Abs.CONST $1 }

SLASH :: { Eo.Abs.SLASH }
SLASH  : L_SLASH { Eo.Abs.SLASH $1 }

COLON :: { Eo.Abs.COLON }
COLON  : L_COLON { Eo.Abs.COLON $1 }

COPY :: { Eo.Abs.COPY }
COPY  : L_COPY { Eo.Abs.COPY $1 }

ARROW :: { Eo.Abs.ARROW }
ARROW  : L_ARROW { Eo.Abs.ARROW $1 }

VERTEX :: { Eo.Abs.VERTEX }
VERTEX  : L_VERTEX { Eo.Abs.VERTEX $1 }

SIGMA :: { Eo.Abs.SIGMA }
SIGMA  : L_SIGMA { Eo.Abs.SIGMA $1 }

XI :: { Eo.Abs.XI }
XI  : L_XI { Eo.Abs.XI $1 }

PLUS :: { Eo.Abs.PLUS }
PLUS  : L_PLUS { Eo.Abs.PLUS $1 }

MINUS :: { Eo.Abs.MINUS }
MINUS  : L_MINUS { Eo.Abs.MINUS $1 }

QUESTION :: { Eo.Abs.QUESTION }
QUESTION  : L_QUESTION { Eo.Abs.QUESTION $1 }

SPACE :: { Eo.Abs.SPACE }
SPACE  : L_SPACE { Eo.Abs.SPACE $1 }

DOT :: { Eo.Abs.DOT }
DOT  : L_DOT { Eo.Abs.DOT $1 }

LSQ :: { Eo.Abs.LSQ }
LSQ  : L_LSQ { Eo.Abs.LSQ $1 }

RSQ :: { Eo.Abs.RSQ }
RSQ  : L_RSQ { Eo.Abs.RSQ $1 }

LB :: { Eo.Abs.LB }
LB  : L_LB { Eo.Abs.LB $1 }

RB :: { Eo.Abs.RB }
RB  : L_RB { Eo.Abs.RB $1 }

AT :: { Eo.Abs.AT }
AT  : L_AT { Eo.Abs.AT $1 }

RHO :: { Eo.Abs.RHO }
RHO  : L_RHO { Eo.Abs.RHO $1 }

HASH :: { Eo.Abs.HASH }
HASH  : L_HASH { Eo.Abs.HASH $1 }

LINEBREAK :: { Eo.Abs.LINEBREAK }
LINEBREAK  : L_LINEBREAK { Eo.Abs.LINEBREAK $1 }

INDENT :: { Eo.Abs.INDENT }
INDENT : SPACE SPACE { Eo.Abs.EINDENT $1 $2 }

INDENT_STAR :: { Eo.Abs.INDENT_STAR }
INDENT_STAR : INDENT { Eo.Abs.EINDENT_STAR $1 }

ListINDENT_STAR :: { [Eo.Abs.INDENT_STAR] }
ListINDENT_STAR
  : {- empty -} { [] } | INDENT_STAR ListINDENT_STAR { (:) $1 $2 }

LINEBREAKA :: { Eo.Abs.LINEBREAKA }
LINEBREAKA
  : LINEBREAK { Eo.Abs.LINEBREAKALINEBREAK $1 }
  | {- empty -} { Eo.Abs.LINEBREAKA_ }

EOL :: { Eo.Abs.EOL }
EOL : LINEBREAK LINEBREAKA ListINDENT_STAR { Eo.Abs.EEOL $1 $2 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

