{- rules Program ::= License? Metas? Objects ;

ELicense. License ::= ( COMMENT EOL )+ ;

EMetas. Metas ::= ( META EOL )+ ;

EObjects. Objects ::= ( Object EOL )+ ;

EObject. Object ::= ( COMMENT EOL )* ( Abstraction | Application ) Tail? ( EOL Method Htail? Suffix? Tail? )* ;

EAbstraction. Abstraction ::= Attributes ( ( Suffix ( SPACE SLASH ( NAME | QUESTION ))?) | Htail )? ;

EAttributes. Attributes ::= LSQ ( Attribute ( SPACE Attribute )*)? RSQ ;

EAttribute. Attribute ::= Label ;

ELabel. Label ::= AT | NAME DOTS? ;

ETail. Tail ::= EOL ( Object EOL )+ ;

ESuffix. Suffix ::= SPACE ARROW SPACE Label CONST? ;

EMethod. Method ::= DOT ( NAME | RHO | AT | VERTEX ) ;

EApplication. Application ::= ( Head | LB Application RB ) Htail? Application1 ;

EApplication. Application1 ::= ( Method | Has | Suffix ) Application1 | '' ; 

EHtail. Htail ::= ( SPACE ( Head | Application ( Method | Has | Suffix ) | LB Application RB | Abstraction ) )+ ;

EHead. Head ::= DOTS? ( ROOT | AT | RHO | XI | SIGMA | STAR | NAME COPY? | NAME DOT | data ) ;

EHas. Has ::= COLON NAME ;

Edata. data ::= BYTES | BOOL | TEXT | STRING | INT | FLOAT | HEX | CHAR | REGEX ;
token COMMENT (HASH (char - ["\r\n"])*);
-- EMETA. META ::= PLUS NAME ( SPACE ~["\r\n"]+)?;
token META (PLUS NAME ( SPACE (char - ["\r\n"])+)?);

-- EREGEX. REGEX ::= SLASH ~[\r\n]+ SLASH [a-z]*;
token REGEX (SLASH (char - ["\r\n"])+ SLASH letter*);
-}


token ROOT 'Q';
token STAR '*';
token DOTS {"..."};
token CONST '!';
token SLASH '/';
token COLON ':';
token COPY '\'';
token ARROW '>';
token VERTEX '<';
token SIGMA '&';
token XI '$';
token PLUS '+';
token MINUS '-';
token QUESTION '?';
token SPACE ' ';
token DOT '.';
token LSQ '[';
token RSQ ']';
token LB '(';
token RB ')';
token AT '@';
token RHO '^';
token HASH '#';

EINDENT. INDENT ::= SPACE SPACE ;
-- ELINEBREAK. LINEBREAK ::= ('\n' | '\r\n') ;
token LINEBREAK ('\n' | {"\r\n"}) ;

EINDENT_STAR. INDENT_STAR ::= INDENT;
[]. [INDENT_STAR] ::= ;
(:). [INDENT_STAR] ::= INDENT_STAR [INDENT_STAR];

rules LINEBREAK_QUESTION ::= LINEBREAK | "";

EEOL. EOL ::= LINEBREAK LINEBREAK_QUESTION [INDENT_STAR] ;

-- {-
-- EBYTE. BYTE ::= [0-9A-F][0-9A-F];
token BYTE (digit | ["ABCDEF"])(digit | ["ABCDEF"]);

EEMPTY_BYTES. EMPTY_BYTES ::= MINUS MINUS;

rules MINUS_BYTE_PLUS ::= MINUS_BYTE_PLUS MINUS BYTE | "";
ELINE_BYTES. LINE_BYTES ::= BYTE MINUS_BYTE_PLUS;


token BYTES ::= EMPTY_BYTES | BYTE MINUS | LINE_BYTES ( MINUS EOL LINE_BYTES )*;

-- EBOOL. BOOL ::= 'TRUE' | 'FALSE';
token BOOL "TRUE" | "FALSE";

-- ECHAR. CHAR ::= '\'' (~['\\\r\n] | ESCAPE_SEQUENCE ) '\'';
token CHAR '\'' ((char - ["\'\\\r\n"]) | ESCAPE_SEQUENCE ) '\'';

token STRING '"' ((char-["\"\\\r\n"]) | ESCAPE_SEQUENCE )* '"';

-- EESCAPE_SEQUENCE. ESCAPE_SEQUENCE ::= "\\" ["btnfr\"\'\\"] | '\\' ([0-3]? [0-7])? [0-7] | '\\' 'u'+ BYTE BYTE ;
token ESCAPE_SEQUENCE '\\' ["btnfr\"\'\\"] | "\\" (["0123"]? ["01234567"])? ["0123467"] | '\\' 'u'+ BYTE BYTE ;

-- EINT. INT ::= ( PLUS | MINUS )? [0-9]+;
token INT ( PLUS | MINUS )? digit+;


-- EEXPONENT. EXPONENT ::= ('e'|'E') ( PLUS | MINUS )? ('0'..'9')+;
token EXPONENT  ('e'|'E') ( PLUS | MINUS )? digit+;

-- EFLOAT. FLOAT ::= ( PLUS | MINUS )? [0-9]+ DOT [0-9]+ EXPONENT?;
token FLOAT ( PLUS | MINUS )? digit+ DOT digit+ EXPONENT?;

-- EHEX. HEX ::= '0x' [0-9a-f]+;
token HEX '0x' (digit | ["abcdef"])+;


-- ENAME. NAME ::= [a-z][\p{Letter}\p{General_Category=Decimal_Number}_-]*;
token NAME lower (letter | digit | '_' | '-')*;

token TEXT_MARK "\"\"\"";
token TEXT TEXT_MARK ("\n" | "\r\n") ((char - '\\') | ESCAPE_SEQUENCE )* TEXT_MARK;
---}

-- короче, просто все правила сделать плоскими до |
